<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Traductor Multilingüe</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;700&display=swap" rel="stylesheet">
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body {
            font-family: 'Inter', sans-serif;
            background-color: #f3f4f6;
            min-height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
            padding: 1rem;
        }
        .main-container {
            max-width: 960px;
            width: 100%;
        }
        .speaker-button {
            background-color: transparent;
            border: none;
            padding: 0.5rem;
            cursor: pointer;
            transition: transform 0.2s ease-in-out;
        }
        .speaker-button:hover {
            transform: scale(1.1);
        }
        .speaker-icon {
            fill: #4b5563;
        }
        .result-item {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 0.75rem 1rem;
            background-color: #fff;
            border-radius: 0.5rem;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            margin-bottom: 0.75rem;
        }
        .language-selector {
            -webkit-appearance: none;
            -moz-appearance: none;
            appearance: none;
            background-image: url('data:image/svg+xml;utf8,<svg fill="none" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20"><path fill="%234B5563" d="M5.293 7.293a1 1 0 011.414 0L10 10.586l3.293-3.293a1 1 0 111.414 1.414l-4 4a1 1 0 01-1.414 0l-4-4a1 1 0 010-1.414z" clip-rule="evenodd" fill-rule="evenodd"/></svg>');
            background-repeat: no-repeat;
            background-position: right 0.5rem center;
            background-size: 1.5em;
        }
        .lang-tag {
            display: inline-flex;
            align-items: center;
            background-color: #e0e7ff;
            color: #3730a3;
            border-radius: 9999px;
            padding: 0.25rem 0.75rem;
            margin-right: 0.5rem;
            margin-bottom: 0.5rem;
            font-size: 0.875rem;
            font-weight: 500;
        }
        .remove-tag {
            margin-left: 0.5rem;
            cursor: pointer;
            color: #4338ca;
            font-weight: bold;
        }
    </style>
</head>
<body class="bg-gray-100">

    <div class="main-container bg-white p-8 rounded-xl shadow-lg">
        <h1 class="text-3xl font-bold text-center text-gray-800 mb-6">Traductor Multilingüe</h1>
        
        <div class="flex flex-col md:flex-row gap-6 mb-6">
            <!-- Panel de Entrada -->
            <div class="flex-1 bg-gray-50 p-6 rounded-lg border border-gray-200">
                <h2 class="text-lg font-semibold text-gray-700 mb-4">Texto de entrada</h2>
                <div class="mb-4">
                    <label for="source-lang" class="block text-gray-600 mb-2">Selecciona el idioma de origen:</label>
                    <select id="source-lang" class="language-selector w-full p-3 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-blue-500"></select>
                </div>
                <textarea id="word-input" class="w-full h-40 p-3 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-blue-500" placeholder="Escribe aquí..."></textarea>
            </div>

            <!-- Panel de Traducción -->
            <div class="flex-1 bg-gray-50 p-6 rounded-lg border border-gray-200">
                <h2 class="text-lg font-semibold text-gray-700 mb-4">Traducción</h2>
                <div class="mb-4">
                    <label for="target-lang-select" class="block text-gray-600 mb-2">Selecciona los idiomas de destino:</label>
                    <div id="selected-langs-container" class="mb-2">
                        <!-- Las etiquetas de idiomas seleccionados se insertarán aquí -->
                    </div>
                    <select id="target-lang-select" class="language-selector w-full p-3 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-blue-500">
                        <option value="" disabled selected>Añadir idioma...</option>
                    </select>
                </div>
                <div id="results-container" class="mt-4">
                    <!-- Los resultados se insertarán aquí -->
                </div>
            </div>
        </div>
        
        <div class="flex justify-center">
            <button id="translate-button" class="bg-blue-600 hover:bg-blue-700 text-white font-semibold py-3 px-8 rounded-lg transition-colors duration-200">
                Traducir
            </button>
        </div>
        
        <div id="loading-spinner" class="hidden text-center mt-6">
            <div class="w-8 h-8 border-4 border-blue-200 border-t-blue-500 rounded-full animate-spin mx-auto"></div>
            <p class="mt-2 text-gray-600">Traduciendo...</p>
        </div>

        <div id="error-message" class="hidden mt-4 p-4 text-red-700 bg-red-100 rounded-lg">
            <!-- Los mensajes de error se mostrarán aquí -->
        </div>
    </div>

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            const wordInput = document.getElementById('word-input');
            const sourceLangSelect = document.getElementById('source-lang');
            const targetLangSelect = document.getElementById('target-lang-select');
            const selectedLangsContainer = document.getElementById('selected-langs-container');
            const translateButton = document.getElementById('translate-button');
            const resultsContainer = document.getElementById('results-container');
            const loadingSpinner = document.getElementById('loading-spinner');
            const errorMessage = document.getElementById('error-message');

            const apiKey = "";
            const geminiApiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-05-20:generateContent?key=${apiKey}`;
            const ttsApiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-tts:generateContent?key=${apiKey}`;

            // A map of voice names for each language code
            const voiceMap = {
                'en': 'Zephyr', 'es': 'Leda', 'zh': 'Laomedeia', 'hi': 'Zubenelgenubi', 'bn': 'Achernar',
                'pt': 'Leda', 'ru': 'Iapetus', 'ja': 'Fenrir', 'mr': 'Sadaltager', 'te': 'Alnilam',
                'ar': 'Kore', 'de': 'Orus', 'fr': 'Puck', 'id': 'Achird', 'it': 'Orus',
                'ko': 'Umbriel', 'nl': 'Sadachbia', 'pl': 'Vindemiatrix', 'ro': 'Rasalgethi',
                'th': 'Vindemiatrix', 'tr': 'Pulcherrima', 'uk': 'Enceladus', 'vi': 'Umbriel',
            };
            
            // A comprehensive list of supported languages
            const allLanguages = [
                // Top 10 most spoken languages (data from 2023)
                { code: 'zh', name: 'Chino Mandarín' },
                { code: 'es', name: 'Español' },
                { code: 'en', name: 'Inglés' },
                { code: 'hi', name: 'Hindi' },
                { code: 'bn', name: 'Bengalí' },
                { code: 'pt', name: 'Portugués' },
                { code: 'ru', name: 'Ruso' },
                { code: 'ja', name: 'Japonés' },
                { code: 'mr', name: 'Marathi' },
                { code: 'te', name: 'Telugu' },
                // Other languages in alphabetical order
                { code: 'ar', name: 'Árabe' },
                { code: 'de', name: 'Alemán' },
                { code: 'fr', name: 'Francés' },
                { code: 'id', name: 'Indonesio' },
                { code: 'it', name: 'Italiano' },
                { code: 'ko', name: 'Coreano' },
                { code: 'nl', name: 'Neerlandés' },
                { code: 'pl', name: 'Polaco' },
                { code: 'ro', name: 'Rumano' },
                { code: 'th', name: 'Tailandés' },
                { code: 'tr', name: 'Turco' },
                { code: 'uk', name: 'Ucraniano' },
                { code: 'vi', name: 'Vietnamita' }
            ].filter(lang => voiceMap[lang.code]); // Filter to only include languages with a defined voice

            // Populate the source language dropdown
            function populateSourceLanguages() {
                allLanguages.forEach(lang => {
                    const option = document.createElement('option');
                    option.value = lang.code;
                    option.textContent = lang.name;
                    sourceLangSelect.appendChild(option);
                });
            }

            // Populate the target language dropdown
            function populateTargetLanguages() {
                // Clear existing options, except the first one
                targetLangSelect.querySelectorAll('option:not([disabled])').forEach(opt => opt.remove());
                const selectedCodes = Array.from(selectedLangsContainer.querySelectorAll('.lang-tag')).map(el => el.dataset.code);
                
                allLanguages.forEach(lang => {
                    if (!selectedCodes.includes(lang.code)) {
                        const option = document.createElement('option');
                        option.value = lang.code;
                        option.textContent = lang.name;
                        targetLangSelect.appendChild(option);
                    }
                });
            }
            
            populateSourceLanguages();
            populateTargetLanguages();
            
            // Event listener to add a language tag when selected from the dropdown
            targetLangSelect.addEventListener('change', (e) => {
                const langCode = e.target.value;
                if (langCode) {
                    const langName = allLanguages.find(lang => lang.code === langCode).name;
                    addLanguageTag(langCode, langName);
                    e.target.value = ''; // Reset dropdown
                }
            });

            // Add a language tag to the selected container
            function addLanguageTag(code, name) {
                const tag = document.createElement('span');
                tag.className = 'lang-tag';
                tag.dataset.code = code;
                tag.textContent = name;
                
                const removeIcon = document.createElement('span');
                removeIcon.className = 'remove-tag';
                removeIcon.innerHTML = '&times;'; // HTML entity for 'x'
                removeIcon.onclick = () => {
                    tag.remove();
                    populateTargetLanguages(); // Repopulate the dropdown
                };

                tag.appendChild(removeIcon);
                selectedLangsContainer.appendChild(tag);
                populateTargetLanguages();
            }

            // Initial selection (Español to English)
            sourceLangSelect.value = 'es';
            addLanguageTag('en', 'Inglés');
            
            // Event listener for the translate button
            translateButton.addEventListener('click', translateText);
            
            async function translateText() {
                const text = wordInput.value.trim();
                const sourceLang = sourceLangSelect.value;
                const targetLangs = Array.from(selectedLangsContainer.querySelectorAll('.lang-tag')).map(el => el.dataset.code);
                
                if (!text) {
                    showError('Por favor, ingresa un texto.');
                    return;
                }
                if (targetLangs.length === 0) {
                    showError('Por favor, selecciona al menos un idioma de destino.');
                    return;
                }
                
                showLoading(true);
                resultsContainer.innerHTML = '';
                showError(false);
                
                try {
                    const translationPromises = targetLangs.map(async (targetLang) => {
                        const langName = allLanguages.find(lang => lang.code === targetLang).name;
                        const prompt = `Translate the following text from ${sourceLang} into ${langName}. The text is: "${text}". Provide the output as a JSON object with a single key for the language code and its translated value. Only provide the JSON object.`;
                        
                        const response = await fetchWithRetry(geminiApiUrl, {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify({
                                contents: [{ parts: [{ text: prompt }] }],
                                generationConfig: {
                                    responseMimeType: "application/json",
                                    responseSchema: buildResponseSchema([targetLang])
                                }
                            })
                        });
                        
                        const result = await response.json();
                        const translatedText = JSON.parse(result.candidates[0].content.parts[0].text)[targetLang];
                        return { langCode: targetLang, translation: translatedText };
                    });

                    const translations = await Promise.all(translationPromises);
                    
                    const translatedTexts = {};
                    translations.forEach(t => {
                        if (t.translation) {
                            translatedTexts[t.langCode] = t.translation;
                        }
                    });

                    renderTranslations(translatedTexts);
                } catch (error) {
                    console.error('Error:', error);
                    showError('No se pudo traducir. Intenta de nuevo.');
                } finally {
                    showLoading(false);
                }
            }

            function buildResponseSchema(langs) {
                const properties = {};
                langs.forEach(lang => {
                    properties[lang] = { type: 'STRING' };
                });
                return { type: 'OBJECT', properties: properties };
            }

            function renderTranslations(translations) {
                for (const langCode in translations) {
                    if (translations.hasOwnProperty(langCode)) {
                        const translationText = translations[langCode];
                        const langName = allLanguages.find(lang => lang.code === langCode)?.name || langCode;
                        
                        if (translationText) {
                            const resultItem = document.createElement('div');
                            resultItem.className = 'result-item';

                            const textSpan = document.createElement('span');
                            textSpan.className = 'text-gray-900';
                            textSpan.innerHTML = `<span class="font-semibold text-blue-700">${langName}:</span> ${translationText}`;

                            const speakerButton = document.createElement('button');
                            speakerButton.className = 'speaker-button';
                            speakerButton.innerHTML = `<svg class="speaker-icon w-6 h-6" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M4 9v6h3l5 5V4L7 9H4zm14.5 3c0-1.77-1-3.29-2.5-4.03v8.05c1.5-.74 2.5-2.26 2.5-4.02zM15 12c0 1.34-.84 2.49-2.02 3.16v-6.33c1.18.67 2.02 1.82 2.02 3.17z"/></svg>`;
                            speakerButton.title = `Reproducir en ${langName}`;
                            speakerButton.onclick = () => speakText(translationText, langCode);

                            resultItem.appendChild(textSpan);
                            resultItem.appendChild(speakerButton);
                            resultsContainer.appendChild(resultItem);
                        }
                    }
                }
            }

            async function speakText(text, langCode) {
                try {
                    const payload = {
                        contents: [{ parts: [{ text: text }] }],
                        generationConfig: {
                            responseModalities: ["AUDIO"],
                            speechConfig: {
                                voiceConfig: {
                                    prebuiltVoiceConfig: { voiceName: voiceMap[langCode] || 'Leda' }
                                }
                            }
                        },
                        model: "gemini-2.5-flash-preview-tts"
                    };

                    const response = await fetchWithRetry(ttsApiUrl, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify(payload)
                    });
                    
                    const result = await response.json();
                    const audioData = result?.candidates?.[0]?.content?.parts?.[0]?.inlineData?.data;
                    const mimeType = result?.candidates?.[0]?.content?.parts?.[0]?.inlineData?.mimeType;

                    if (audioData && mimeType && mimeType.startsWith("audio/")) {
                        const audioContext = new (window.AudioContext || window.webkitAudioContext)();
                        const sampleRateMatch = mimeType.match(/rate=(\d+)/);
                        const sampleRate = sampleRateMatch ? parseInt(sampleRateMatch[1], 10) : 16000;
                        
                        const pcmData = base64ToArrayBuffer(audioData);
                        const pcm16 = new Int16Array(pcmData);

                        const wavBlob = pcmToWav(pcm16, sampleRate);
                        const audioUrl = URL.createObjectURL(wavBlob);
                        
                        const audio = new Audio(audioUrl);
                        audio.play();

                    } else {
                        throw new Error("Respuesta de audio no válida de la API.");
                    }

                } catch (error) {
                    console.error("Error al reproducir el audio:", error);
                    showError('No se pudo reproducir el audio.');
                }
            }
            
            // Helper functions for TTS audio conversion
            function base64ToArrayBuffer(base64) {
                const binaryString = atob(base64);
                const len = binaryString.length;
                const bytes = new Uint8Array(len);
                for (let i = 0; i < len; i++) {
                    bytes[i] = binaryString.charCodeAt(i);
                }
                return bytes.buffer;
            }

            function pcmToWav(pcmData, sampleRate) {
                const wavHeader = new ArrayBuffer(44);
                const view = new DataView(wavHeader);

                writeString(view, 0, 'RIFF');
                view.setUint32(4, 36 + pcmData.byteLength, true); 
                writeString(view, 8, 'WAVE');

                writeString(view, 12, 'fmt ');
                view.setUint32(16, 16, true);
                view.setUint16(20, 1, true);
                view.setUint16(22, 1, true);
                view.setUint32(24, sampleRate, true);
                view.setUint32(28, sampleRate * 2, true);
                view.setUint16(32, 2, true);
                view.setUint16(34, 16, true);

                writeString(view, 36, 'data');
                view.setUint32(40, pcmData.byteLength, true);

                const finalBuffer = new Uint8Array(wavHeader.byteLength + pcmData.byteLength);
                finalBuffer.set(new Uint8Array(wavHeader), 0);
                finalBuffer.set(new Uint8Array(pcmData.buffer), wavHeader.byteLength);

                return new Blob([finalBuffer], { type: 'audio/wav' });
            }

            function writeString(view, offset, string) {
                for (let i = 0; i < string.length; i++) {
                    view.setUint8(offset + i, string.charCodeAt(i));
                }
            }
            
            // Utility functions for UI
            function showLoading(show) {
                loadingSpinner.classList.toggle('hidden', !show);
                translateButton.disabled = show;
                wordInput.disabled = show;
                sourceLangSelect.disabled = show;
                targetLangSelect.disabled = show;
            }

            function showError(message) {
                if (message) {
                    errorMessage.textContent = message;
                    errorMessage.classList.remove('hidden');
                } else {
                    errorMessage.classList.add('hidden');
                }
            }

            async function fetchWithRetry(url, options, retries = 3, delay = 1000) {
                try {
                    const response = await fetch(url, options);
                    if (!response.ok) {
                        const errorText = await response.text();
                        throw new Error(`HTTP error! status: ${response.status}, message: ${errorText}`);
                    }
                    return response;
                } catch (error) {
                    if (retries > 0) {
                        await new Promise(res => setTimeout(res, delay));
                        return fetchWithRetry(url, options, retries - 1, delay * 2);
                    } else {
                        throw error;
                    }
                }
            }
        });
    </script>
</body>
</html>
